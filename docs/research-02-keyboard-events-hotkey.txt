================================================================================
EchoType v0.2.0 ç ”ç©¶å ±å‘Š #2 â€” macOS éµç›¤äº‹ä»¶èˆ‡å¿«æ·éµå¯¦ä½œ
æ—¥æœŸ: 2026-02-19
================================================================================

ä¸€ã€macOS éµç›¤äº‹ä»¶ç³»çµ±
================================================================================

1.1 CGEvent vs NSEvent
----------------------

macOS æœ‰å…©å±¤éµç›¤äº‹ä»¶ APIï¼š

CGEvent (Core Graphics, C-level):
  - æœ€åº•å±¤çš„ userspace éµç›¤äº‹ä»¶ API
  - äº‹ä»¶é¡å‹ï¼škCGEventKeyDown (10), kCGEventKeyUp (11), kCGEventFlagsChanged (12)
  - kCGEventFlagsChanged æ˜¯é—œéµ â€” modifier éµä¸æœƒç”¢ç”Ÿ keyDown/keyUpï¼Œåªç”¢ç”Ÿ flagsChanged
  - æ¯å€‹ CGEvent å¸¶æœ‰ CGEventTimestampï¼ˆmach absolute time, å¥ˆç§’ç²¾åº¦ï¼‰
  - å¯é€é CGEventTapCreate å»ºç«‹å…¨åŸŸäº‹ä»¶æ””æˆª

NSEvent (AppKit, Objective-C/Swift level):
  - å°è£ CGEvent çš„é«˜éš API
  - NSEvent.addGlobalMonitorForEvents(matching:handler:) â€” ç›£è½å…¶ä»– appï¼ˆåªè®€ï¼‰
  - NSEvent.addLocalMonitorForEvents(matching:handler:) â€” ç›£è½è‡ªå·± appï¼ˆå¯ä¿®æ”¹ï¼‰
  - äº‹ä»¶é¡å‹ï¼š.keyDown, .keyUp, .flagsChanged
  - NSEvent.timestamp æ˜¯ TimeIntervalï¼ˆç§’ï¼Œå¾ç³»çµ±å•Ÿå‹•ç®—èµ·ï¼‰

1.2 fn / Globe éµçš„ç‰¹æ®Šæ€§
--------------------------

é€™æ˜¯æ•´å€‹æ–¹æ¡ˆä¸­æœ€æ£˜æ‰‹çš„éƒ¨åˆ†ï¼š

1. fn éµä¸ç”¢ç”Ÿ keyDown/keyUp â€” å®ƒæ˜¯ modifier keyï¼Œåªè§¸ç™¼ flagsChanged
2. modifier flag å€¼ï¼šfn éµå°æ‡‰ NSEvent.ModifierFlags.function
   raw value = 0x800000 (å³ 1 << 23)
   CGEvent å±¤é¢æ˜¯ kCGEventFlagMaskSecondaryFn = 0x800000
3. macOS Monterey (12.0) ä¹‹å¾Œï¼šApple å°‡ fn éµé‡æ–°å®šç¾©ç‚º Globe éµï¼ˆğŸŒï¼‰
   é è¨­è¡Œç‚ºè®Šæˆé–‹å•Ÿ Emoji é¸æ“‡å™¨æˆ–åˆ‡æ›è¼¸å…¥æ³•
4. macOS Ventura (13.0)+ï¼šç³»çµ±åå¥½è¨­å®šä¸­å¯é¸æ“‡ fn éµè¡Œç‚ºï¼š
   - "æŒ‰ä¸‹ ğŸŒ éµæ™‚" â†’ "æ›´æ”¹è¼¸å…¥æ–¹å¼" / "é–‹å§‹è½å¯«" / "é¡¯ç¤ºè¡¨æƒ…ç¬¦è™Ÿèˆ‡ç¬¦è™Ÿ" / "ä¸åšä»»ä½•å‹•ä½œ"
5. é—œéµå•é¡Œï¼šç•¶ fn è¨­å®šç‚ºã€Œé–‹å§‹è½å¯«ã€æ™‚ï¼Œç³»çµ±æœƒæ””æˆªé›™æ“Š fn äº‹ä»¶ï¼Œ
   CGEventTap å¯èƒ½æ”¶ä¸åˆ°å®Œæ•´äº‹ä»¶ã€‚è¨­å®šç‚ºã€Œä¸åšä»»ä½•å‹•ä½œã€æ™‚æœ€å®¹æ˜“æ””æˆªã€‚

1.3 flagsChanged äº‹ä»¶åµæ¸¬é‚è¼¯ (è™›æ“¬ç¢¼)
---------------------------------------

fn handle_flags_changed(event: CGEvent) {
    let flags = event.get_flags();
    let fn_pressed = flags & 0x800000 != 0;

    if fn_pressed && !self.was_fn_pressed {
        // fn éµå‰›æŒ‰ä¸‹
        self.fn_press_time = event.timestamp();
        self.was_fn_pressed = true;
    } else if !fn_pressed && self.was_fn_pressed {
        // fn éµå‰›æ”¾é–‹
        let hold_duration = event.timestamp() - self.fn_press_time;
        self.was_fn_pressed = false;
        // æ ¹æ“š hold_duration åˆ¤å®šé•·æŒ‰ vs é»æŒ‰
    }
}

äºŒã€é•·æŒ‰ vs é»æŒ‰çš„åˆ¤å®šé‚è¼¯
================================================================================

2.1 æ™‚é–“é–¾å€¼
------------

| è¡Œç‚º              | é–¾å€¼    | èªªæ˜                    |
|-------------------|---------|-------------------------|
| é»æŒ‰ (tap)        | < 300ms | æŒ‰ä¸‹åˆ°æ”¾é–‹çš„æ™‚é–“        |
| é•·æŒ‰ (hold)       | >= 300ms| æŒ‰ä½è¶…éé–¾å€¼            |
| é›™æ“Š (double-tap) | < 400ms | å…©æ¬¡ tap ä¹‹é–“çš„æ™‚é–“     |

æ¨è–¦ EchoType ä½¿ç”¨çš„é–¾å€¼ï¼š
  - é•·æŒ‰é–¾å€¼ï¼š300msï¼ˆå¤ªçŸ­å®¹æ˜“èª¤è§¸ï¼Œå¤ªé•·é«”é©—é²éˆï¼‰
  - é•·æŒ‰å•Ÿå‹•å»¶é²ï¼šæŒ‰ä½ 300ms å¾Œæ‰é–‹å§‹éŒ„éŸ³
  - é›™æ“Šçª—å£ï¼š400ms
  - æœ€çŸ­éŒ„éŸ³æ™‚é•·ï¼š500msï¼ˆå¤ªçŸ­ä¸Ÿæ£„ï¼‰

2.2 é˜²èª¤è§¸ç­–ç•¥
--------------

1. é•·æŒ‰å•Ÿå‹•å»¶é² (hold threshold)ï¼šæŒ‰ä½è¶…é 300ms å¾Œæ‰å•Ÿå‹•éŒ„éŸ³
2. æœ€çŸ­éŒ„éŸ³æ™‚é•·ï¼šéŒ„éŸ³æ™‚é•· < 500ms å‰‡ä¸Ÿæ£„çµæœ
3. debounceï¼šå¿½ç•¥ 50ms å…§çš„é‡è¤‡ flagsChanged äº‹ä»¶
4. çµ„åˆéµæ’é™¤ï¼šfn + å…¶ä»–éµåŒæ™‚æŒ‰ä¸‹æ™‚ä¸è§¸ç™¼éŒ„éŸ³

2.3 ç‹€æ…‹æ©Ÿè¨­è¨ˆ
--------------

                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                                     â”‚
                    â–¼                                     â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   fn down    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
              â”‚   IDLE   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚  PENDING     â”‚  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚  (ç­‰å¾…åˆ¤å®š)   â”‚  â”‚
                    â–²                   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
                    â”‚                          â”‚          â”‚
                    â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                    â”‚              â”‚           â”‚          â”‚
                    â”‚    fn up     â”‚  300ms    â”‚  fn up   â”‚
                    â”‚   < 300ms    â”‚  elapsed  â”‚  (å–æ¶ˆ)  â”‚
                    â”‚              â”‚           â”‚          â”‚
                    â”‚              â–¼           â”‚          â”‚
                    â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚          â”‚
                    â”‚    â”‚  TAP         â”‚      â”‚          â”‚
                    â”‚    â”‚  (toggle)    â”‚â”€â”€â”€â”€â”€â”€â”˜          â”‚
                    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
                    â”‚                                     â”‚
                    â”‚         300ms timer fires            â”‚
                    â”‚              â”‚                       â”‚
                    â”‚              â–¼                       â”‚
                    â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
                    â”‚    â”‚  HOLDING     â”‚                  â”‚
                    â”‚    â”‚  (éŒ„éŸ³ä¸­)    â”‚                  â”‚
                    â”‚    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
                    â”‚           â”‚                          â”‚
                    â”‚      fn up                           â”‚
                    â”‚           â”‚                          â”‚
                    â”‚           â–¼                          â”‚
                    â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
                    â””â”€â”€â”€â”€â”‚  RELEASED    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚  (åœæ­¢éŒ„éŸ³)  â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å…©ç¨®éŒ„éŸ³æ¨¡å¼ï¼š
  - é•·æŒ‰æ¨¡å¼ (push-to-talk)ï¼šæŒ‰ä½ fn > 300ms â†’ é–‹å§‹éŒ„éŸ³ â†’ æ”¾é–‹ â†’ åœæ­¢ä¸¦è½‰æ–‡å­—
  - é»æŒ‰æ¨¡å¼ (toggle)ï¼šçŸ­æŒ‰ fn < 300ms â†’ é–‹å§‹éŒ„éŸ³ â†’ å†çŸ­æŒ‰ â†’ åœæ­¢ä¸¦è½‰æ–‡å­—

ä¸‰ã€å…¨åŸŸéµç›¤ç›£è½æŠ€è¡“æ–¹æ¡ˆæ¯”è¼ƒ
================================================================================

3.1 æ–¹æ¡ˆ Aï¼šCGEventTapï¼ˆæ¨è–¦ï¼‰
------------------------------

C API ç°½åï¼š
  CGEventTapRef CGEventTapCreate(
      CGEventTapLocation      tap,        // kCGSessionEventTap
      CGEventTapPlacement     place,      // kCGHeadInsertEventTap
      CGEventTapOptions       options,    // kCGEventTapOptionListenOnly
      CGEventMask             eventsOfInterest,  // 1 << 12
      CGEventTapCallBack      callback,
      void *                  userInfo
  );

é—œéµåƒæ•¸ï¼š
  - tap: kCGSessionEventTapï¼ˆç•¶å‰ä½¿ç”¨è€… sessionï¼‰
  - options: kCGEventTapOptionListenOnlyï¼ˆåªç›£è½ä¸æ””æˆªï¼‰
    å¦‚éœ€æ””æˆª fn é è¨­è¡Œç‚ºï¼Œç”¨ kCGEventTapOptionDefault
  - eventsOfInterest: CGEventMaskBit(kCGEventFlagsChanged) = 1 << 12

æ¬Šé™éœ€æ±‚ï¼š
  - Accessibility æ¬Šé™ï¼ˆç³»çµ±åå¥½è¨­å®š â†’ éš±ç§èˆ‡å®‰å…¨æ€§ â†’ è¼”åŠ©ä½¿ç”¨ï¼‰
  - macOS 10.15+ ListenOnly ä¹Ÿéœ€è¦ Accessibility æ¬Šé™

3.2 æ–¹æ¡ˆ Bï¼šNSEvent.addGlobalMonitorForEvents
----------------------------------------------

Swift å¯¦ä½œï¼š
  NSEvent.addGlobalMonitorForEvents(matching: .flagsChanged) { event in
      let fnPressed = event.modifierFlags.contains(.function)
  }

é™åˆ¶ï¼š
  - åªèƒ½ç›£è½ï¼Œä¸èƒ½æ””æˆª/ä¿®æ”¹äº‹ä»¶
  - ä¸èƒ½é˜»æ­¢ fn éµçš„é è¨­è¡Œç‚º
  - åŒæ¨£éœ€è¦ Accessibility æ¬Šé™
  - å° EchoType å¤ ç”¨ï¼ˆåªéœ€ç›£è½ä¸éœ€æ””æˆªï¼‰

3.3 æ–¹æ¡ˆ Cï¼šIOHIDManagerï¼ˆæœ€åº•å±¤ï¼‰
----------------------------------

  - ç›´æ¥å¾ HID é©…å‹•è®€å–
  - å¯æ•ç²æ‰€æœ‰éµç›¤äº‹ä»¶ï¼ŒåŒ…æ‹¬è¢«ç³»çµ±æ””æˆªçš„
  - éœ€è¦ root æ¬Šé™æˆ– IOKit entitlement
  - éæ–¼åº•å±¤ï¼Œç¶­è­·æˆæœ¬é«˜
  - ä¸æ¨è–¦

3.4 æ–¹æ¡ˆæ¯”è¼ƒè¡¨
--------------

| ç‰¹æ€§       | CGEventTap      | NSEvent Global  | IOHIDManager    |
|------------|-----------------|-----------------|-----------------|
| èªè¨€       | C (Rust FFI å‹å¥½)| ObjC/Swift     | C (Rust FFI)    |
| æ””æˆªäº‹ä»¶   | å¯ä»¥            | ä¸è¡Œ            | å¯ä»¥            |
| fn éµæ”¯æ´  | flagsChanged    | flagsChanged    | åŸå§‹ HID äº‹ä»¶   |
| æ¬Šé™       | Accessibility   | Accessibility   | root/entitlement|
| è¤‡é›œåº¦     | ä¸­              | ä½              | é«˜              |
| æ¨è–¦åº¦     | â˜…â˜…â˜… é¦–é¸       | â˜…â˜… å‚™é¸        | â˜… ä¸æ¨è–¦       |

å››ã€æ¨è–¦æ¶æ§‹ï¼šRust ç«¯ç›´æ¥ CGEventTap
================================================================================

4.1 æ¶æ§‹åœ–
----------

Tauri App
  â”œâ”€â”€ keyboard.rs (æ”¹é€ )
  â”‚     â”œâ”€â”€ CGEventTap (é€é core-graphics crate æˆ–æ‰‹å‹• FFI)
  â”‚     â”œâ”€â”€ fn éµç‹€æ…‹æ©Ÿ
  â”‚     â”œâ”€â”€ é•·æŒ‰/é»æŒ‰åˆ¤å®š
  â”‚     â””â”€â”€ emit Tauri events (hotkey-pressed, hotkey-released, hotkey-tap)
  â”‚
  â”œâ”€â”€ bridge.rs (ä¸è®Š)
  â”‚     â””â”€â”€ JSON-IPC â†’ EchoTypeHelper
  â”‚
  â””â”€â”€ å‰ç«¯ (å°æ”¹)
        â””â”€â”€ æ–°å¢ç›£è½ hotkey-tap äº‹ä»¶

æ¨è–¦åŸå› ï¼š
  1. ä¸éœ€è¦ä¿®æ”¹ç¾æœ‰çš„ bridge.rs IPC æ¶æ§‹
  2. ä¸éœ€è¦é¡å¤–çš„é€²ç¨‹
  3. core-graphics crate å·²åœ¨ Cargo.lock ä¸­ï¼ˆTauri é–“æ¥ä¾è³´ï¼‰
  4. äº‹ä»¶è™•ç†åœ¨ Rust ç«¯å®Œæˆï¼Œå»¶é²æœ€ä½
  5. èˆ‡ç¾æœ‰ keyboard.rs æ¶æ§‹ä¸€è‡´

4.2 Cargo.toml æ–°å¢ä¾è³´
------------------------

core-graphics = "0.24"
core-foundation = "0.10"

4.3 Rust ç«¯ keyboard.rs æ”¹é€ æ–¹æ¡ˆ
---------------------------------

use core_graphics::event::*;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tauri::{AppHandle, Emitter};

const HOLD_THRESHOLD_MS: u64 = 300;
const MIN_RECORDING_MS: u64 = 500;

#[derive(Debug, Clone, Copy, PartialEq)]
enum FnKeyState {
    Idle,
    Pending,    // fn æŒ‰ä¸‹ï¼Œç­‰å¾…åˆ¤å®š
    Holding,    // ç¢ºèªé•·æŒ‰ï¼ŒéŒ„éŸ³ä¸­
    Recording,  // é»æŒ‰è§¸ç™¼çš„ toggle éŒ„éŸ³
}

pub fn start_fn_key_listener(app: AppHandle) {
    std::thread::spawn(move || {
        let state = Arc::new(std::sync::Mutex::new(FnKeyState::Idle));
        let press_time = Arc::new(std::sync::Mutex::new(Instant::now()));

        let mask = CGEventMaskBit(CGEventType::FlagsChanged);

        // å»ºç«‹ event tap (å¯èƒ½éœ€è¦æ‰‹å‹• FFI)
        let tap = create_event_tap(mask, move |event_type, event| {
            let flags = event.get_flags();
            let fn_down = (flags.bits() & 0x800000) != 0;

            let mut current_state = state.lock().unwrap();

            match (*current_state, fn_down) {
                (FnKeyState::Idle, true) => {
                    *press_time.lock().unwrap() = Instant::now();
                    *current_state = FnKeyState::Pending;

                    // å•Ÿå‹• 300ms è¨ˆæ™‚å™¨
                    let app2 = app.clone();
                    let state2 = state.clone();
                    std::thread::spawn(move || {
                        std::thread::sleep(Duration::from_millis(HOLD_THRESHOLD_MS));
                        let mut s = state2.lock().unwrap();
                        if *s == FnKeyState::Pending {
                            *s = FnKeyState::Holding;
                            let _ = app2.emit("hotkey-pressed", "fn-hold");
                        }
                    });
                }

                (FnKeyState::Pending, false) => {
                    *current_state = FnKeyState::Idle;
                    let _ = app.emit("hotkey-tap", "fn-tap");
                }

                (FnKeyState::Holding, false) => {
                    *current_state = FnKeyState::Idle;
                    let elapsed = press_time.lock().unwrap().elapsed();
                    if elapsed.as_millis() > MIN_RECORDING_MS as u128 {
                        let _ = app.emit("hotkey-released", "fn-hold");
                    } else {
                        let _ = app.emit("hotkey-cancelled", "too-short");
                    }
                }

                _ => {}
            }
        });

        core_foundation::runloop::CFRunLoop::run_current();
    });
}

4.4 æ‰‹å‹• CGEventTap FFIï¼ˆcore-graphics crate å°è£ä¸å®Œæ•´æ™‚ï¼‰
------------------------------------------------------------

use core_foundation::runloop::*;
use core_foundation::mach_port::*;
use std::ffi::c_void;
use std::os::raw::c_uint;

type CGEventRef = *mut c_void;
type CGEventTapProxy = *mut c_void;
type CGEventMask = u64;
type CGEventType = c_uint;

const kCGEventFlagsChanged: CGEventType = 12;
const kCGSessionEventTap: c_uint = 1;
const kCGHeadInsertEventTap: c_uint = 0;
const kCGEventTapOptionListenOnly: c_uint = 1;
const kCGEventFlagMaskSecondaryFn: u64 = 0x800000;

type CGEventTapCallBack = extern "C" fn(
    proxy: CGEventTapProxy,
    event_type: CGEventType,
    event: CGEventRef,
    user_info: *mut c_void,
) -> CGEventRef;

extern "C" {
    fn CGEventTapCreate(
        tap: c_uint, place: c_uint, options: c_uint,
        events_of_interest: CGEventMask,
        callback: CGEventTapCallBack,
        user_info: *mut c_void,
    ) -> CFMachPortRef;

    fn CGEventGetFlags(event: CGEventRef) -> u64;
    fn CGEventGetTimestamp(event: CGEventRef) -> u64;
    fn CGEventTapEnable(tap: CFMachPortRef, enable: bool);
    fn CFMachPortCreateRunLoopSource(
        allocator: *const c_void, port: CFMachPortRef, order: isize,
    ) -> CFRunLoopSourceRef;
}

extern "C" fn event_tap_callback(
    _proxy: CGEventTapProxy,
    event_type: CGEventType,
    event: CGEventRef,
    user_info: *mut c_void,
) -> CGEventRef {
    if event_type == kCGEventFlagsChanged {
        let flags = unsafe { CGEventGetFlags(event) };
        let fn_pressed = (flags & kCGEventFlagMaskSecondaryFn) != 0;
        let sender = unsafe { &*(user_info as *const std::sync::mpsc::Sender<bool>) };
        let _ = sender.send(fn_pressed);
    }
    event
}

4.5 å‰ç«¯æ•´åˆï¼ˆä¿®æ”¹ FloatingBar.tsxï¼‰
-------------------------------------

useEffect(() => {
    const unlisten1 = listen("hotkey-pressed", () => handleStartRecording());
    const unlisten2 = listen("hotkey-released", () => handleStopRecording());
    const unlisten3 = listen("hotkey-tap", () => {
        if (stateRef.current === "idle") {
            handleStartRecording();
        } else if (stateRef.current === "recording") {
            handleStopRecording();
        }
    });
    const unlisten4 = listen("hotkey-cancelled", () => {
        // éŒ„éŸ³å¤ªçŸ­ï¼Œå–æ¶ˆï¼Œå¯é¡¯ç¤ºçŸ­æš«æç¤º
    });

    return () => {
        unlisten1.then(f => f());
        unlisten2.then(f => f());
        unlisten3.then(f => f());
        unlisten4.then(f => f());
    };
}, [handleStartRecording, handleStopRecording]);

äº”ã€å·²çŸ¥çš„å‘å’Œæ³¨æ„äº‹é …
================================================================================

5.1 fn/Globe éµçš„ç³»çµ±è¡çª
- macOS è½å¯«åŠŸèƒ½ï¼šé›™æ“Š fn å•Ÿå‹•è½å¯«æ™‚ç³»çµ±æœƒæ””æˆªäº‹ä»¶
  â†’ å»ºè­° onboarding å¼•å°ç”¨æˆ¶å°‡ fn è¨­ç‚ºã€Œä¸åšä»»ä½•å‹•ä½œã€
  â†’ ç³»çµ±è¨­å®š â†’ éµç›¤ â†’ éµç›¤å¿«æ·éµ â†’ åŠŸèƒ½éµ â†’ æŒ‰ä¸‹ ğŸŒ éµæ™‚ â†’ ä¸åšä»»ä½•å‹•ä½œ

5.2 CGEventTap è¢«ç³»çµ±åœç”¨
- callback è™•ç†å¤ªæ…¢ï¼ˆè¶…éå¹¾ç§’ï¼‰macOS æœƒè‡ªå‹•åœç”¨ event tap
- éœ€è¦å®šæœŸæª¢æŸ¥ä¸¦é‡æ–°å•Ÿç”¨ï¼š
  if !CGEventTapIsEnabled(tap) { CGEventTapEnable(tap, true); }

5.3 æ²™ç›’é™åˆ¶
- App Store åˆ†ç™¼çš„æ²™ç›’åŒ– app ç„¡æ³•ä½¿ç”¨ CGEventTap
- EchoType æ‡‰ä½¿ç”¨ Developer ID ç°½å + å…¬è­‰ç›´æ¥åˆ†ç™¼

5.4 é›™æ“Šåµæ¸¬çš„å»¶é²å•é¡Œ
- é›™æ“Šåµæ¸¬æœƒè®“å–®æ“ŠéŸ¿æ‡‰å»¶é² 400msï¼ˆéœ€ç­‰å¾…ç¢ºèªä¸æ˜¯é›™æ“Šï¼‰
- å¦‚ä¸éœ€è¦é›™æ“ŠåŠŸèƒ½ï¼Œå»ºè­°ä¸å¯¦ä½œï¼Œä¿æŒå–®æ“Šå³æ™‚éŸ¿æ‡‰

5.5 Typeless çš„å¿«æ·éµé…ç½®åƒè€ƒ
- pushToTalk: "Fn"
- handlesFreeMode: "Fn+Space"
- pasteLastTranscript: "LeftCtrl+LeftCmd+V"
- translationMode: "Fn+LeftShift"

å…­ã€æ¬Šé™æª¢æŸ¥ Rust å¯¦ä½œ
================================================================================

extern "C" {
    fn AXIsProcessTrustedWithOptions(options: *const c_void) -> bool;
}

pub fn check_accessibility_permission(prompt: bool) -> bool {
    unsafe {
        if prompt {
            let key = core_foundation::string::CFString::new("AXTrustedCheckOptionPrompt");
            let value = core_foundation::boolean::CFBoolean::true_value();
            let options = core_foundation::dictionary::CFDictionary::from_CFType_pairs(&[
                (key.as_CFType(), value.as_CFType())
            ]);
            AXIsProcessTrustedWithOptions(options.as_concrete_TypeRef() as *const c_void)
        } else {
            AXIsProcessTrustedWithOptions(std::ptr::null())
        }
    }
}
